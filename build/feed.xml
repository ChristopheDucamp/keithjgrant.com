<?xml version="1.0" encoding="utf-8" ?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Keith J Grant</title><link>http://keithjgrant.com</link><atom:link href="http://keithjgrant.com/feed.xml" rel="self" type="application/rss+xml"/><description>JavaScript, CSS, UX, and the open web</description><language>en-US</language><lastBuildDate>Sat, 30 May 2015 04:00:00 GMT</lastBuildDate><item><title>Into the Future of CSS</title><link>http://keithjgrant.com/posts/into-the-future-of-css.html</link><description><![CDATA[
<p>In my <a href="/posts/against-css-in-js.html">last post</a>, I laid out why I think moving our CSS into JavaScript is not a good idea.  If am totally honest, however, I have to admit I brushed off the concerns <a href="https://twitter.com/vjeux">Christopher Chedeaux</a> raises in his slidedeck.  The seven problems he named can be mitigated by best practices, and most of us can do just fine, because we do not often work in apps of the same scale as Facebook or Google.  But that does not mean the problems aren&#39;t worth discussion.</p>
<p>I may disagree with the solution proposed by the ReactJS team, but I think they are doing something very important by bringing these problems to the forefront.  I shot down their ideas in my last post, so now I want to follow up with some constructive ideas.</p>
<h2 id="a-way-forward">A Way Forward</h2>
<p>We need to figure out how to solve these problems.  Not just mitigate them or work around them, but full solutions that work at scale.  And if the current spec does not provide the means, we should work to discover what additions to the spec can get us there.</p>
<p>I think our best bet is learning from JavaScript, or more specifically, CoffeeScript and Babel.  Now that ES6 features are becoming supported more and more in browsers, we can see that CoffeeScript played an important role in making that happen.  CoffeeScript brought new syntax and important improvements like auto bound functions (i.e. <code>=&gt;</code>) and, thanks to a transpiler, made them possible even before browsers supported them.  Now, some of these features have made their way into ES6 and with them, a breath of new life.  Even more new features are being proposed, and we can use them today with Babel.</p>
<p>We already have two promising libraries, doing for CSS what Babel does for JavaScript: <a href="https://github.com/postcss/postcss">PostCSS</a> and <a href="http://cssnext.io/">cssnext</a>.  These transpile CSS using the latest spec into compatible CSS that works in browsers today.  This is huge.  Things that we&#39;ve relied on SASS and LESS for can now be done in &quot;pure&quot; CSS, namely variables and advanced color functions.  They also include support for things like custom media queries and custom selectors.  If you are not familiar with either of these libraries, they are worth reading up on.</p>
<p>The problem is these additions to spec are not all that exciting.  Variables and color functions are nice conveniences, but they do little to solve the real difficulties we face with CSS at scale.  I think, instead of emulating Babel, we need to emulate CoffeeScript.  It pushed the boundaries of JS, and now, as a result, 60% of ES6 features came straight from CoffeeScript.  Let&#39;s do the same thing with CSS.  Think outside the box, and dream up new features to help.  PostCSS is especially good for this, because it is modular.  We just need to start writing some experimental plugins.</p>
<h2 id="scoped-css">Scoped CSS</h2>
<p>One cutting-edge feature that I think has promise is <a href="http://davidwalsh.name/scoped-css">scoped css</a>.  This allows us to add a &quot;scoped&quot; attribute to a style tag, and those styles will only be applied to the parent element of the style tag and its descendants.  For example:</p>
<pre><code class="lang-html">&lt;div class=&quot;outer&quot;&gt;
  &lt;p&gt;Normal black text&lt;/p&gt;
  &lt;div class=&quot;inner&quot;&gt;
    &lt;style scoped&gt;
      p { color: red; }
    &lt;/style&gt;
    &lt;p&gt;Red text!&lt;/p&gt;
  &lt;/div&gt;
  &lt;p&gt;Normal black text&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>These can be nested, and scoped elements can even be targeted in our regular stylesheet with the <code>:scoped</code> pseudo-class.  Scoped styles override styles from a higher-up scope or the global page, regardless of selector specificity.</p>
<p>The spec for this was proposed in 2011, and not much has happened with it since then.  Only Firefox has added support.  Chrome added support behind an experimental features flag&mdash;but has since removed it.  There are polyfills available, but as it is, this has not gone very far, and it&#39;s not hard to see why.  Who wants to write a bunch of CSS inline in the document?  That feels more like a step backwards.</p>
<p>So, here&#39;s an idea.  What if we assigned a value to the scoped attribute, <code>&lt;style scoped=&quot;widget&quot;/&gt;</code>, and then create an at-rule to define a named scope, maybe something like this:</p>
<pre><code class="lang-css">@scope(&#39;widget&#39;) {
  p {
    color: red;
  }
}
</code></pre>
<p>This would define a set of scoped styles and assign them a scope name, then we can use that name to apply those styles to our component wherever we put it on the page.  Then we could combine a PostCSS plugin with a polyfill to make it work.  Again, this is just an idea.  I don&#39;t really know how well it will solve our difficulties in practice, but I would sure like to try.  It sure seems to have promise at addressing nearly all of Christopher Chedeaux&#39;s seven problems with CSS at scale.</p>
<h2 id="let-s-start-experimenting">Let&#39;s Start Experimenting</h2>
<p>Maybe my enhanced scope idea won&#39;t work out.  Maybe someone else will come up with a better idea.  Either way, I think we need to try.  Perhaps there is something to be found if we augmented <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@namespace">@namespace</a> instead.  Maybe the answer lies with the shadow DOM and web components, or something else entirely new.</p>
<p>My hope here is not that we come up with a postprocessor or polyfill library that makes CSS easier, though that is the first step.  My hope is ultimately that we find a way to solve the problems we have, and that the best solution makes its way into the official spec, after we prove it out on production sites. Who knows?  Maybe if PostCSS or cssnext keeps gaining traction, we will invent entirely new polyfills for the future that address any number of issues.  JavaScript has got a lot of momentum moving forward.  It&#39;s time for CSS to do the same.</p>

]]></description><pubDate>Sat, 30 May 2015 04:00:00 GMT</pubDate><guid isPermaLink="true">http://keithjgrant.com/posts/into-the-future-of-css.html</guid></item><item><title>Against CSS in JS</title><link>http://keithjgrant.com/posts/against-css-in-js.html</link><description><![CDATA[
<p><blockquote class="twitter-tweet" lang="en"><p lang="en" dir="ltr">Some folks want a unified language of the web instead of CSS, HTML, and JS.&#10;&#10;It&#39;s increasingly looking like JS will just eat the other two.</p>&mdash; Henrik Joreteg (@HenrikJoreteg) <a href="https://twitter.com/HenrikJoreteg/status/603959629425483776">May 28, 2015</a></blockquote></p>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>I have long believed that our <a href="https://www.youtube.com/watch?v=x7cQ3mrcKaY">JavaScript is intimately coupled with the DOM</a>, especially in the context of web apps.  For far too long, we waved our hands and pretended we have a separation of concerns simply because our HTML is in one file and our JavaScript is in another.  Not only did this avoid the problem, I think it actually made it worse, because we had to write more and more complicated code to try and abstract away this coupling.</p>
<p>This coupling is real, and it is unavoidable.  We must bind event listeners to elements on the page.  We must update elements on the page from our JavaScript.  Our code must interact bidirectionally and in real-time with the elements of the DOM.  If it doesn&#39;t... then we just have static HTML.  Think about it, can you just open up your HTML and change around class names or ids without breaking anything?  Of course not.  You have to pull up your scripts and see which of those you need to get a handle on various DOM nodes.  Likewise, when you make changes to your JavaScript views, you inevitably need to make changes to the markup as well; add a class or id so you can target an element; wrap an extra div around a block so you can animate it a certain way.  This is the very definition of tight coupling.  You must have an intimate knowledge of both in order to safely make any substantive changes to either.</p>
<p>Instead, the mantra of React is to stop pretending the DOM and the JavaScript that controls it are separate concerns.  Join the two, and instead, separate concerns that are actually different: the dropdown menu is separate from the list of objects; the modal dialog box is separate from the page footer.  Why on earth would you put these all in the same HTML document?  Obviously, you shouldn&#39;t.</p>
<p>When React came out, I was more than happy to embrace their controversial claim that pieces of our DOM should live in the JavaScript&mdash;because I already knew it to be true.  They are the same concern, and every attempt we have ever made at separating them has ended in disaster.  Just think about the last time you had to deal with Backbone Views.  It actually makes me feel sick to my stomach to think about.  There was so much work for so little gain, and it was all boilerplate code to cross that barrier into DOM land.</p>
<h2 id="so-what-about-css-">So What About CSS?</h2>
<p>This made sense once, so, naturally, there is talk about doing the same thing with CSS.  We brought our HTML (sort of) into our JavaScript and it cleaned a lot of things up, why not <a href="https://medium.com/javascript-scene/jsx-looks-like-an-abomination-1c1ec351a918#1e2d">do it with our styles</a> as well?</p>
<p>This is a really bad idea.  Where, with JSX, my reaction was, &quot;Yes, finally!&quot;, my response here is quite the opposite.  I&#39;ve had a hard time articulating exactly why I respond this way, especially on the length-constrained and fast-paced atmosphere of Twitter, so I&#39;m setting out now to articulate my reasons here.</p>
<p>Before I dive in too deep, I do want to say I have interacted some with React Native folks on Twitter regarding this.  I acknowledge that their work is primarily in the realm of native applications, not in the context of the web.  I think this has ramifications for their use case that I myself am not familiar with.  My thoughts may be applicable to them, and they may not; I&#39;m not well-versed in that world enough to speak to them directly.  But I do hope others take note of that distinction before they clamber to repeat these practices on the web.</p>
<h2 id="we-are-not-solving-the-same-problem-as-before">We Are Not Solving the Same Problem As Before</h2>
<p>The relationship between CSS and JavaScript is not like the relationship between HTML and JavaScript.  With HTML, a true separation of concerns between the markup and the corresponding component code is impossible (because they are in fact the same concern).  With CSS, this separation is possible.  And, in fact, the concerns are unique, so separation is vital to clean code organization.</p>
<p>Your CSS should be wholly independent from your markup (and especially independent from your JavaScript).  If you find, as <a href="http://programmers.stackexchange.com/questions/271294/why-is-it-or-was-it-important-to-separate-css-from-html">this stackexchange user observed</a>&mdash;that your &quot;commit history shows me the opposite - [you] usually edit both HTML and CSS together&quot;&mdash;then you are doing CSS wrong.  CSS should not depend on the markup; the markup should depend on the CSS.  Or, more accurately, it should depend on the modular, reusable API defined by the CSS.</p>
<p>If you use the best practices of <a href="http://oocss.org/">OOCSS</a>, <a href="https://smacss.com/">SMACSS</a>, or BEM, you will not need to edit the CSS every time you edit a page.  In fact, once you have your basic building blocks of CSS defined, you can build out all sorts of things in the markup before you need to touch the styles again.  Far too often, developers write their CSS and HTML together, with selectors that mimic the structure of the DOM.  If one changes, then the other must change with it: a tight coupling.</p>
<p>However, moving the styles into the JavaScript does not address this problem at all.  When we moved our HTML into our React components, we redefined which concerns we were separating.  Each component is now a unique concern.  When we bring CSS into that, we are not further breaking up our concerns; we are just adding more responsibilities to the concerns we already have.</p>
<p>In a best-case scenario, with well organized code, we require in a style module into our React component and add it to the props.  This is roughly equivalent to adding a class name that references a stylesheet--there is no net gain in terms of separation of concerns.  But, we don&#39;t always work in a best-case scenario.  Now that our JavaScript has taken responsibility for styling, it will have to take care of things that we take for granted with CSS.  This will add unnecessary bloat to your codebase, and make separation of concerns more difficult.</p>
<p>If your stylesheets are well organized and written with best practices, there is no bi-directional dependency between them and the HTML.  So we do not need to solve the same problem with our CSS that we had to solve with our markup.</p>
<h2 id="beware-framework-lock-in">Beware Framework Lock-In</h2>
<p>CSS is universal. If your page has stylesheets, that&#39;s cool, because everyone&#39;s page has stylesheets.  Every JavaScript library and every HTML templating language works with CSS.  If you shift all of your styles into JavaScript, you are going to be locked into using JavaScript libraries that can use them.  Your styles no longer stand on their own.</p>
<p>If in 14 months you find a new view library or framework you want to try out, you&#39;re out of luck.  You will have to invest a lot of time into pulling styles back out of JavaScript modules and into stylesheets again.  The most likely scenario is you would only bring out a portion of it&mdash;just enough to use in the components you are building with the new library.  Sure, you may continue to make progress over time pulling styles back into regular stylesheets, but during that process, you&#39;re going to have duplication of code, and you may even find yourself running into scenarios where the CSS has to be completely re-written to replicate the behavior you added in JavaScript.</p>
<h2 id="all-or-nothing">All or Nothing</h2>
<p>When you start bringing your styles into your JavaScript, where do you stop?  If you only bring in some of them, how are you going to define that boundary?  When you need to change something in the look and feel, do you know whether you need to open up your styles.css or your styles.js?  The only logical solution here is to bring in all of it and abondon stylesheets altogether.</p>
<p>The problem with that is, CSS takes care of some things cleanly for us that you are probably taking for granted.  This is helpful for fonts in particular: The default font size, the font face and line-height, and the color of your font are all inherited silently from one of the topmost elements on the page.  Do you want to explicitly set these things on every single component you build?  Because you will have to.</p>
<p>Not only that, but if you distribute your component, the users of that component need to be all-in on the same paradigm, as well.  Your component sets inline styles, which means they can&#39;t be overridden without <code>!important</code>.  To get around this problem, you can allow the user to pass in their own styles, but this means the user of your component must have their styles defined in their JavaScript as well.  What if they want to use traditional stylesheets?  You&#39;re forcing their hand.</p>
<h2 id="missing-css-features">Missing CSS Features</h2>
<p>I think there is a place for a few inline styles in a React component.  I&#39;ll admit I&#39;ve had to do it a few times.  Most often, though, it is because I need to accomplish something that can&#39;t be done in pure CSS (yet), such as animating from <code>height: 0</code> to <code>height: auto</code>.  Animation is a bit of a different topic here, but, honestly, even that is invariably easier to do when it can be accomplished with pure CSS.  The power of transitions and keyframe animation is much harder to replicate in JavaScript without the help of yet another dependency.  The browser already has this stuff built in.  Take advantage of it.  It is so much easier to just toggle a classname and not have to think about it when I&#39;m trying to focus on another problem.</p>
<p>You also lose the ability to do some other things, as well, like media queries and fallback values for older browsers.  Unless you want to start browser sniffing and adding conditionals around your styles.  Again, this is adding more responsibilities to your components that otherwise they would not have.</p>
<h2 id="in-defense-of-css">In Defense Of CSS</h2>
<p>At this point, I have to ask: what problem are we trying to solve?  There is a lot of baggage and many unknowns if we start doing CSS-in-JS.  We had better have a damn good reason before we go down that road.  Christopher Chedeau, in the <a href="https://speakerdeck.com/vjeux/react-css-in-js">original slidedeck</a> that introduced this idea, outlines seven &quot;problems&quot; with CSS.  The thing is, they are solvable problems.  If we as web developers just understand CSS better, and take the time to learn modern best-practices like SMACSS and BEM, these issues almost entirely dissolve, especially at the scale most of us work at.  Don&#39;t get me wrong; he does make some good points that are worth discussing, but I believe we have at least partial solutions for all of them (some of the latest proposals to the CSS spec help, as well).  If you want to discuss those points directly, feel free to ping me on <a href="https://twitter.com/keithjgrant">Twitter</a>.</p>
<p>Many web developers fear CSS.  They fear it because the do not understand it.  And I am worried that, in that fear, we will collectively rush to move our styles into JavaScript in hopes that it solves our problems.  It won&#39;t.</p>
<p>It&#39;s time to truly <a href="https://github.com/keithjgrant/Taming-CSS">learn CSS</a>, because that&#39;s our real problem.  And that is a problem we can fix.</p>
<p><br/><em>Update: I have written a follow-up post: <a href="/posts/into-the-future-of-css.html">Into the Future of CSS</a></em></p>

]]></description><pubDate>Fri, 29 May 2015 04:00:00 GMT</pubDate><guid isPermaLink="true">http://keithjgrant.com/posts/against-css-in-js.html</guid></item><item><title>Hosting on Github</title><link>http://keithjgrant.com/posts/hosting-on-github.html</link><description><![CDATA[
<p>Well, this is a bit of an experiment... I&#39;ve lost track of how many times I&#39;ve started a redesign of my WordPress blog, only to give up after days of fiddling.  This is kind of silly, since I generally finish the <em>design</em> of my site fairly quickly, but get held up fighting with the implementation minutae.</p>
<p>I blog very rarely.  I also occasionally want to host various other pages that don&#39;t necessarily need to fit with the theme of the rest of my site.  WordPress is really overkill for this.  What I really need is just some static hosting.  So I&#39;m giving GitHub Pages a try.  Not only that, but I should be able to play with the design whenever I feel like, without too much time investment.</p>
<p>So here&#39;s my new design.  It took me just a few days not only to build the site, but to also roll out some bare-bones blogging &amp; deployment scripts in gulp; my database is a git repository.  I can blog in <a href="http://jade-lang.com/">Jade</a> or MarkDown.  I think my wordpress days may be done, at least for now.</p>

]]></description><pubDate>Sat, 16 May 2015 04:00:00 GMT</pubDate><guid isPermaLink="true">http://keithjgrant.com/posts/hosting-on-github.html</guid></item><item><title>Taming CSS</title><link>http://keithjgrant.com/posts/taming-css.html</link><description><![CDATA[
<p>Observation 1: Web developers, in general, don’t know CSS as well as they should.</p>
<p>Observation 2: There aren’t really any good roadmaps for learning all the essentials of CSS.</p>
<p>There are great resources for the basics, for styling, for code organization/architecture, for advanced tricks. But to work through them all, you get a lot of overlap, and they still leave you with missing gaps in your knowledge. Often, with CSS, you don’t know what you don’t know, and that makes it hard to move forward. My hope is to fix that, by putting them all together in one place.</p>
<p>Announcing <a href="https://github.com/keithjgrant/Taming-CSS">Taming CSS</a>, a CSS book for web developers.</p>

]]></description><pubDate>Wed, 29 Apr 2015 04:00:00 GMT</pubDate><guid isPermaLink="true">http://keithjgrant.com/posts/taming-css.html</guid></item></channel></rss>