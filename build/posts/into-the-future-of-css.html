<!DOCTYPE html><head><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><title>Into the Future of CSS | Keith J Grant</title><meta name="description" content=""><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="theme-color" content="#666"><link rel="alternate" type="application/rss+xml" title="Keith J Grant" href="http://keithjgrant.com/feed.xml"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif|Palanquin:100,700" type="text/css"><link rel="stylesheet" href="/css/main.min.css"></head><body><nav class="topnav"><ul><li><a href="/">Home</a></li><li><a href="/about">About</a></li><li><a href="/posts">Posts</a></li><li><a href="/talks">Talks</a></li></ul></nav><div class="masthead"><h1 class="page-title">Into the Future of CSS</h1></div><main class="l-main"><article class="post"><div class="post-content"><p>In my <a href="/posts/against-css-in-js.html">last post</a>, I laid out why I think moving our CSS into JavaScript is not a good idea.  If am totally honest, however, I have to admit I brushed off the concerns <a href="https://twitter.com/vjeux">Christopher Chedeaux</a> raises in his slidedeck.  The seven problems he named can be mitigated by best practices, and most of us can do just fine, because we do not often work in apps of the same scale as Facebook or Google.  But that does not mean the problems aren&#39;t worth discussion.</p>
<p>I may disagree with the solution proposed by the ReactJS team, but I think they are doing something very important by bringing these problems to the forefront.  I shot down their ideas in my last post, so now I want to follow up with some constructive ideas.</p>
<h2 id="a-way-forward">A Way Forward</h2>
<p>We need to figure out how to solve these problems.  Not just mitigate them or work around them, but full solutions that work at scale.  And if the current spec does not provide the means, we should work to discover what additions to the spec can get us there.</p>
<p>I think our best bet is learning from JavaScript, or more specifically, CoffeeScript and Babel.  Now that ES6 features are becoming supported more and more in browsers, we can see that CoffeeScript played an important role in making that happen.  CoffeeScript brought new syntax and important improvements like auto bound functions (i.e. <code>=&gt;</code>) and, thanks to a transpiler, made them possible even before browsers supported them.  Now, some of these features have made their way into ES6 and with them, a breath of new life.  Even more new features are being proposed, and we can use them today with Babel.</p>
<p>We already have two promising libraries, doing for CSS what Babel does for JavaScript: <a href="https://github.com/postcss/postcss">PostCSS</a> and <a href="http://cssnext.io/">cssnext</a>.  These transpile CSS using the latest spec into compatible CSS that works in browsers today.  This is huge.  Things that we&#39;ve relied on SASS and LESS for can now be done in &quot;pure&quot; CSS, namely variables and advanced color functions.  They also include support for things like custom media queries and custom selectors.  If you are not familiar with either of these libraries, they are worth reading up on.</p>
<p>The problem is these additions to spec are not all that exciting.  Variables and color functions are nice conveniences, but they do little to solve the real difficulties we face with CSS at scale.  I think, instead of emulating Babel, we need to emulate CoffeeScript.  It pushed the boundaries of JS, and now, as a result, 60% of ES6 features came straight from CoffeeScript.  Let&#39;s do the same thing with CSS.  Think outside the box, and dream up new features to help.  PostCSS is especially good for this, because it is modular.  We just need to start writing some experimental plugins.</p>
<h2 id="scoped-css">Scoped CSS</h2>
<p>One cutting-edge feature that I think has promise is <a href="http://davidwalsh.name/scoped-css">scoped css</a>.  This allows us to add a &quot;scoped&quot; attribute to a style tag, and those styles will only be applied to the parent element of the style tag and its descendants.  For example:</p>
<pre><code class="lang-html">&lt;div class=&quot;outer&quot;&gt;
  &lt;p&gt;Normal black text&lt;/p&gt;
  &lt;div class=&quot;inner&quot;&gt;
    &lt;style scoped&gt;
      p { color: red; }
    &lt;/style&gt;
    &lt;p&gt;Red text!&lt;/p&gt;
  &lt;/div&gt;
  &lt;p&gt;Normal black text&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>These can be nested, and scoped elements can even be targeted in our regular stylesheet with the <code>:scoped</code> pseudo-class.  Scoped styles override styles from a higher-up scope or the global page, regardless of selector specificity.</p>
<p>The spec for this was proposed in 2011, and not much has happened with it since then.  Only Firefox has added support.  Chrome added support behind an experimental features flag&mdash;but has since removed it.  There are polyfills available, but as it is, this has not gone very far, and it&#39;s not hard to see why.  Who wants to write a bunch of CSS inline in the document?  That feels more like a step backwards.</p>
<p>So, here&#39;s an idea.  What if we assigned a value to the scoped attribute, <code class="prettyprint">&lt;style scoped=&quot;widget&quot;/&gt;</code>, and then create an at-rule to define a named scope, maybe something like this:</p>
<pre><code class="lang-css">@scope(&#39;widget&#39;) {
  p {
    color: red;
  }
}
</code></pre>
<p>This would define a set of scoped styles and assign them a scope name, then we can use that name to apply those styles to our component wherever we put it on the page.  Then we could combine a PostCSS plugin with a polyfill to make it work.  Again, this is just an idea.  I don&#39;t really know how well it will solve our difficulties in practice, but I would sure like to try.  It sure seems to have promise at addressing nearly all of Christopher Chedeaux&#39;s seven problems with CSS at scale.</p>
<h2 id="let-s-start-experimenting">Let&#39;s Start Experimenting</h2>
<p>Maybe my enhanced scope idea won&#39;t work out.  Maybe someone else will come up with a better idea.  Either way, I think we need to try.  Perhaps there is something to be found if we augmented <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@namespace">@namespace</a> instead.  Maybe the answer lies with the shadow DOM and web components, or something else entirely new.</p>
<p>My hope here is not that we come up with a postprocessor or polyfill library that makes CSS easier, though that is the first step.  My hope is ultimately that we find a way to solve the problems we have, and that the best solution makes its way into the official spec, after we prove it out on production sites. Who knows?  Maybe if PostCSS or cssnext keeps gaining traction, we will invent entirely new polyfills for the future that address any number of issues.  JavaScript has got a lot of momentum moving forward.  It&#39;s time for CSS to do the same.</p>
</div><date class="post-date">30 May 2015</date></article><footer><a href="/posts">See more posts</a></footer></main><script src="/js/vendor/prettify.js"></script><script src="/js/run-prettify.js"></script><script>if (document.location.hostname !== 'localhost') {
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-37381912-2', 'auto');
  ga('send', 'pageview');
}</script></body>